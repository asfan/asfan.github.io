---
layout: post
title: 分布式队列设计（1）
category: 架构
tags: 架构、模式
keywords: MQ、Kafka、RabbitMQ、RocketMQ、NSQ
description: 分布式队列设计第一部分，入门
---

###背景
随着开发经验逐渐积累，学着总结设计中的“套路”，实际上在大型分布式系统的搭建过程中，有很多领域是需要深入研究，能够实现对相关知识的遍历，也可以保证自己在之后开发过程中的触类旁通。实际上从系统层面上需要解决的问题，后续会补一下分布式缓存的坑，并把redis源码分析补充一下。  
每个具体组件的解决方案都相对有穷。要达到专家的程度就要达到走一路、清一路。本文先总结一下进来调研MQ相关的**应用场景**、**设计关键点**、**最佳实践组件**对比。同时为内部队列leviathan设定设计约束，保证其在业内先进性。

--

###参考资料

--


###正文

####MQ使用场景
- **异步通信**  
  这是MQ最常见的使用场景。业务中往往存在一些对响应时间不敏感又很耗时的操作，这时把这种消息放入队列中，当前连接/操作直接返回。队列中堆积的消息由其他进程/操作去进行单独消费。
- **解耦**  
  当两个系统进行交互时，往往在项目伊始无法确定两端（或者其中任意一端）的业务逻辑，通常进行一个标准的数据定义，无论双端如何修改，只要保证数据定义不变，就可以对对接方透明。MQ也是这样的一个基于数据的接口层，保证了两个复杂系统之间的松散耦合。
- **冗余**  
  在现代分布式系统中的复杂网络环境下，数据处理的过程一定会出现失败的情况。在对数据一致性要求不高的系统中，可以降级处理。但在金融、金融衍生以及用户特别关注的场景下，不能随意的对这部分数据进行丢失处理。这时提供符合AMQP协议或者是“插入->获取->删除”范式的MQ服务，可以保证数据一直持久化，直到被处理。
- **可扩展**  
  MQ只作为生产者、消费者传输message的通道，可以很简单的通过增加实例增加整体系统的吞吐能力，进而很容易进行扩缩容操作。
- **灵活性&削峰填谷**
  
- 可恢复
- 顺序
- 缓冲


####MQ设计常用标准

####常见MQ特征对比

对于MQ影响吞吐的有数据包大小、进线程占有资源大小等多个先决条件，做横向对比测试时要保障约束相同。

| 队列名称 | 实现语言 | 支持语言 | 投递方式（消费模型） | 持久化 | 消息模式 | 吞吐能力 | 可伸缩性 | 消息分区 | 处理数据类型 | 实时性 | 分布式结构 |
|---|---|---|---|---|---|---|---|---|---|---|---|
|kafka | scala | Java、.NET、PHP、Ruby、Python | （message pull模式）最多？最少？恰好？1次 | O(1)方式持久化，TB级数据常数时间复杂度访问性能 | | 普通机器单机100k条/s | 支持在线水平扩展 |支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输| 同时支持离线数据处理和实时数据处理 | 消息由producer产生后立即对consumer可见。（这个特性对于基于事件的系统很关键） | Broker的中心化集群支持消息分区，consumer采用分布式进行消费 实验 99分位3ms [实验地址](http://wanlitian.github.io/2015/11/04/kafka-performance/)|
|RocketMQ | java | java php | 最少？恰好？| 可配置 异步同步/同步双写 + 同步刷盘/异步刷盘 4中组合都可以配置|
| RabbitMQ | Erlang | Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等 | 完全实现AMQP应用层协议 | 可配置，关键使用场景为queue、message、exchange的持久化
| NSQ | Golang | |


